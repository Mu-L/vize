===
name: simple v-once
options: default
--- INPUT ---
<div v-once>static</div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, createTextVNode as _createTextVNode, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div", null, [
      _createTextVNode("static")
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once with interpolation
options: default
--- INPUT ---
<div v-once>{{ msg }}</div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div", null, [
      _createTextVNode(_toDisplayString(_ctx.msg), 1 /* TEXT */)
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once with binding
options: default
--- INPUT ---
<div v-once :class="cls">content</div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, createTextVNode as _createTextVNode, normalizeClass as _normalizeClass, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div", {
      class: _normalizeClass(_ctx.cls)
    }, [
      _createTextVNode("content")
    ], 2 /* CLASS */)).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once on component
options: default
--- INPUT ---
<MyComponent v-once />
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, resolveComponent as _resolveComponent, createVNode as _createVNode } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createVNode(_component_MyComponent)).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once on template
options: default
--- INPUT ---
<template v-once><div>A</div><div>B</div></template>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("template", null, [
      _createElementVNode("div", null, "A"),
      _createElementVNode("div", null, "B")
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once with nested dynamic
options: default
--- INPUT ---
<div v-once><span :class="cls">{{ msg }}</span></div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div", null, [
      _createElementVNode("span", {
        class: _normalizeClass(_ctx.cls)
      }, _toDisplayString(_ctx.msg), 3 /* TEXT, CLASS */)
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once inside v-for
options: default
--- INPUT ---
<div v-for="item in items" :key="item.id"><span v-once>{{ item.static }}</span></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, setBlockTracking as _setBlockTracking, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {
    return (_openBlock(), _createElementBlock("div", {
      key: item.id
    }, [
      _cache[0] || (
        _setBlockTracking(-1, true),
        (_cache[0] = _createElementVNode("span", null, [
          _createTextVNode(_toDisplayString(item.static), 1 /* TEXT */)
        ])).cacheIndex = 0,
        _setBlockTracking(1),
        _cache[0]
      )
    ]))
  }), 128 /* KEYED_FRAGMENT */))
}

===
name: basic v-memo
options: default
--- INPUT ---
<div v-memo="[value]">{{ computed }}</div>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([_ctx.value], () => (_openBlock(), _createElementBlock("div", null, [
    _createTextVNode(_toDisplayString(_ctx.computed), 1 /* TEXT */)
  ])), _cache, 0)
}

===
name: v-memo multiple deps
options: default
--- INPUT ---
<div v-memo="[a, b, c]">{{ result }}</div>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([_ctx.a, _ctx.b, _ctx.c], () => (_openBlock(), _createElementBlock("div", null, [
    _createTextVNode(_toDisplayString(_ctx.result), 1 /* TEXT */)
  ])), _cache, 0)
}

===
name: v-memo empty array
options: default
--- INPUT ---
<div v-memo="[]">static</div>
--- OUTPUT ---
import { createTextVNode as _createTextVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([], () => (_openBlock(), _createElementBlock("div", null, [
    _createTextVNode("static")
  ])), _cache, 0)
}

===
name: v-memo on component
options: default
--- INPUT ---
<MyComponent v-memo="[prop]" :prop="prop" />
--- OUTPUT ---
import { resolveComponent as _resolveComponent, createVNode as _createVNode, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return _withMemo([_ctx.prop], () => _createVNode(_component_MyComponent, { prop: _ctx.prop }, null, 8 /* PROPS */, ["prop"]), _cache, 0)
}

===
name: v-memo in v-for
options: default
--- INPUT ---
<div v-for="item in items" :key="item.id" v-memo="[item.selected]">{{ item.name }}</div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, isMemoSame as _isMemoSame, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item, __, ___, _cached) => {
    const _memo = ([item.selected])
    if (_cached && _cached.key === item.id && _isMemoSame(_cached, _memo)) return _cached
    const _item = (_openBlock(), _createElementBlock("div", {
      key: item.id
    }, [
      _createTextVNode(_toDisplayString(item.name), 1 /* TEXT */)
    ]))
    _item.memo = _memo
    return _item
  }, _cache, 0), 128 /* KEYED_FRAGMENT */))
}

===
name: v-memo with complex expression
options: default
--- INPUT ---
<div v-for="item in items" :key="item.id" v-memo="[item.id === selected]">{{ item.name }}</div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, isMemoSame as _isMemoSame, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item, __, ___, _cached) => {
    const _memo = ([item.id === _ctx.selected])
    if (_cached && _cached.key === item.id && _isMemoSame(_cached, _memo)) return _cached
    const _item = (_openBlock(), _createElementBlock("div", {
      key: item.id
    }, [
      _createTextVNode(_toDisplayString(item.name), 1 /* TEXT */)
    ]))
    _item.memo = _memo
    return _item
  }, _cache, 0), 128 /* KEYED_FRAGMENT */))
}

===
name: v-memo on template
options: default
--- INPUT ---
<template v-memo="[value]"><div>A</div><div>B</div></template>
--- OUTPUT ---
import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([_ctx.value], () => (_openBlock(), _createElementBlock("template", null, [
    _createElementVNode("div", null, "A"),
    _createElementVNode("div", null, "B")
  ])), _cache, 0)
}
