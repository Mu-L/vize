===
name: v-if directive
options: default
--- INPUT ---
<div v-if="show"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.show)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with no value
options: default
errors: v-if/v-else-if is missing expression.
--- INPUT ---
<div v-if/>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return true
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with complex expression
options: default
--- INPUT ---
<div v-if="a && b || c"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.a && _ctx.b || _ctx.c)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with method call
options: default
--- INPUT ---
<div v-if="shouldShow()"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.shouldShow())
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with negation
options: default
--- INPUT ---
<div v-if="!hidden"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (!_ctx.hidden)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with comparison
options: default
--- INPUT ---
<div v-if="count > 0"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.count > 0)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with ternary
options: default
--- INPUT ---
<div v-if="ok ? yes : no"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.ok ? _ctx.yes : _ctx.no)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-if with member expression
options: default
--- INPUT ---
<div v-if="item.visible"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.item.visible)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }))
    : _createCommentVNode("v-if", true)
}

===
name: v-else directive
options: default
errors: v-else/v-else-if has no adjacent v-if or v-else-if.
--- INPUT ---
<div v-else></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div"))
}

===
name: v-else-if directive
options: default
errors: v-else/v-else-if has no adjacent v-if or v-else-if.
--- INPUT ---
<div v-else-if="condition"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div"))
}

===
name: v-else-if with complex condition
options: default
errors: v-else/v-else-if has no adjacent v-if or v-else-if.
--- INPUT ---
<div v-else-if="type === 2 && enabled"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div"))
}

===
name: v-if with v-else chain
options: default
--- INPUT ---
<div v-if="a">A</div><div v-else>B</div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.a)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }, "A"))
    : (_openBlock(), _createElementBlock("div", { key: 1 }, "B"))
}

===
name: v-if with v-else-if chain
options: default
--- INPUT ---
<div v-if="a">A</div><div v-else-if="b">B</div><div v-else>C</div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.a)
    ? (_openBlock(), _createElementBlock("div", { key: 0 }, "A"))
    : (_ctx.b)
      ? (_openBlock(), _createElementBlock("div", { key: 1 }, "B"))
      : (_openBlock(), _createElementBlock("div", { key: 2 }, "C"))
}

===
name: v-if on template
options: default
--- INPUT ---
<template v-if="show"><div>a</div><div>b</div></template>
--- OUTPUT ---
import { createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.show)
    ? (_openBlock(), _createElementBlock(_Fragment, { key: 0 }, [
        _createElementVNode("div", null, "a"),
        _createElementVNode("div", null, "b")
      ], 64 /* STABLE_FRAGMENT */))
    : _createCommentVNode("v-if", true)
}

===
name: v-for directive
options: default
--- INPUT ---
<div v-for="item in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with index
options: default
--- INPUT ---
<div v-for="(item, index) in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item, index) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with key and index
options: default
--- INPUT ---
<div v-for="(value, key, index) in object"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.object, (value, key, index) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with of keyword
options: default
--- INPUT ---
<div v-for="item of items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with destructuring
options: default
--- INPUT ---
<div v-for="{ id, name } in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, ({ id, name }) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with array destructuring
options: default
--- INPUT ---
<div v-for="[a, b] in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, ([a, b]) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with nested destructuring
options: default
--- INPUT ---
<div v-for="{ nested: { value } } in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, ({ nested: { value } }) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with default value
options: default
--- INPUT ---
<div v-for="{ id = 0 } in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, ({ id = 0 }) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with rest operator
options: default
--- INPUT ---
<div v-for="{ id, ...rest } in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, ({ id, ...rest }) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with range
options: default
--- INPUT ---
<div v-for="n in 10"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock(_Fragment, null, _renderList(10, (n) => {
    return _createElementVNode("div")
  }), 64 /* STABLE_FRAGMENT */))
}

===
name: v-for with method call
options: default
--- INPUT ---
<div v-for="item in getItems()"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.getItems(), (item) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with computed source
options: default
--- INPUT ---
<div v-for="item in filteredItems"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.filteredItems, (item) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with chained methods
options: default
--- INPUT ---
<div v-for="item in items.filter(x => x.active)"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items.filter(x => x.active), (item) => {
    return (_openBlock(), _createElementBlock("div"))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with inline array
options: default
--- INPUT ---
<div v-for="item in [1, 2, 3]"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock(_Fragment, null, _renderList([1, 2, 3], (item) => {
    return _createElementVNode("div")
  }), 64 /* STABLE_FRAGMENT */))
}

===
name: v-for with inline object
options: default
--- INPUT ---
<div v-for="(value, key) in { a: 1, b: 2 }"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock(_Fragment, null, _renderList({ a: 1, b: 2 }, (value, key) => {
    return _createElementVNode("div")
  }), 64 /* STABLE_FRAGMENT */))
}

===
name: v-for on template
options: default
--- INPUT ---
<template v-for="item in items"><div>{{ item }}</div></template>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {
    return (_openBlock(), _createElementBlock("div", null, _toDisplayString(item), 1 /* TEXT */))
  }), 256 /* UNKEYED_FRAGMENT */))
}

===
name: v-for with key attribute
options: default
--- INPUT ---
<div v-for="item in items" :key="item.id"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {
    return (_openBlock(), _createElementBlock("div", {
      key: item.id
    }))
  }), 128 /* KEYED_FRAGMENT */))
}

===
name: v-for with static key
options: default
--- INPUT ---
<div v-for="item in items" key="static"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item) => {
    return (_openBlock(), _createElementBlock("div", { key: "static" }))
  }), 128 /* KEYED_FRAGMENT */))
}

===
name: v-bind directive
options: default
--- INPUT ---
<div v-bind:id="id"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { id: _ctx.id }, null, 8 /* PROPS */, ["id"]))
}

===
name: v-bind shorthand
options: default
--- INPUT ---
<div :id="id"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { id: _ctx.id }, null, 8 /* PROPS */, ["id"]))
}

===
name: v-bind with no expression
options: default
--- INPUT ---
<div v-bind:id />
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { id: _ctx.id }, null, 8 /* PROPS */, ["id"]))
}

===
name: v-bind shorthand with no expression
options: default
--- INPUT ---
<div :id />
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { id: _ctx.id }, null, 8 /* PROPS */, ["id"]))
}

===
name: v-bind with dynamic arg
options: default
--- INPUT ---
<div v-bind:[key]="value"></div>
--- OUTPUT ---
import { normalizeProps as _normalizeProps, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _normalizeProps({ [_ctx.key || ""]: _ctx.value }), null, 16 /* FULL_PROPS */))
}

===
name: v-bind shorthand with dynamic arg
options: default
--- INPUT ---
<div :[key]="value"></div>
--- OUTPUT ---
import { normalizeProps as _normalizeProps, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _normalizeProps({ [_ctx.key || ""]: _ctx.value }), null, 16 /* FULL_PROPS */))
}

===
name: v-bind with complex dynamic arg
options: default
errors: End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.; v-bind with same-name shorthand only allows static argument.; v-bind is missing expression.
--- INPUT ---
<div :[foo + bar]="value"></div>
--- OUTPUT ---
import { normalizeProps as _normalizeProps, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _normalizeProps({
    [_ctx.foo]: "",
    "+": "",
    "bar]": "value"
  }), null, 16 /* FULL_PROPS */))
}

===
name: v-bind with modifiers
options: default
--- INPUT ---
<div :id.camel="id"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { id: _ctx.id }, null, 8 /* PROPS */, ["id"]))
}

===
name: v-bind with .prop modifier
options: default
--- INPUT ---
<div :inner-html.prop="html"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { ".inner-html": _ctx.html }, null, 40 /* PROPS, NEED_HYDRATION */, [".inner-html"]))
}

===
name: v-bind with .attr modifier
options: default
--- INPUT ---
<div :id.attr="id"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { "^id": _ctx.id }, null, 8 /* PROPS */, ["^id"]))
}

===
name: v-bind with .sync modifier (v2 compat)
options: default
--- INPUT ---
<div :value.sync="val"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { value: _ctx.val }, null, 8 /* PROPS */, ["value"]))
}

===
name: v-bind with multiple modifiers
options: default
--- INPUT ---
<div :foo-bar.camel.prop="value"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { ".fooBar": _ctx.value }, null, 40 /* PROPS, NEED_HYDRATION */, [".fooBar"]))
}

===
name: v-bind object
options: default
--- INPUT ---
<div v-bind="attrs"></div>
--- OUTPUT ---
import { normalizeProps as _normalizeProps, guardReactiveProps as _guardReactiveProps, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _normalizeProps(_guardReactiveProps(_ctx.attrs)), null, 16 /* FULL_PROPS */))
}

===
name: v-bind object with other props
options: default
--- INPUT ---
<div v-bind="attrs" :id="id"></div>
--- OUTPUT ---
import { mergeProps as _mergeProps, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _mergeProps(_ctx.attrs, { id: _ctx.id }), null, 16 /* FULL_PROPS */, ["id"]))
}

===
name: v-bind class
options: default
--- INPUT ---
<div :class="{ active: isActive }"></div>
--- OUTPUT ---
import { normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    class: _normalizeClass({ active: _ctx.isActive })
  }, null, 2 /* CLASS */))
}

===
name: v-bind class array
options: default
--- INPUT ---
<div :class="[a, b]"></div>
--- OUTPUT ---
import { normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    class: _normalizeClass([_ctx.a, _ctx.b])
  }, null, 2 /* CLASS */))
}

===
name: v-bind class mixed
options: default
--- INPUT ---
<div :class="[{ active: isActive }, errorClass]"></div>
--- OUTPUT ---
import { normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    class: _normalizeClass([{ active: _ctx.isActive }, _ctx.errorClass])
  }, null, 2 /* CLASS */))
}

===
name: v-bind style object
options: default
--- INPUT ---
<div :style="{ color: activeColor }"></div>
--- OUTPUT ---
import { normalizeStyle as _normalizeStyle, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    style: _normalizeStyle({ color: _ctx.activeColor })
  }, null, 4 /* STYLE */))
}

===
name: v-bind style array
options: default
--- INPUT ---
<div :style="[baseStyles, overridingStyles]"></div>
--- OUTPUT ---
import { normalizeStyle as _normalizeStyle, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    style: _normalizeStyle([_ctx.baseStyles, _ctx.overridingStyles])
  }, null, 4 /* STYLE */))
}

===
name: v-bind with expression
options: default
--- INPUT ---
<div :id="a + b"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    id: _ctx.a + _ctx.b
  }, null, 8 /* PROPS */, ["id"]))
}

===
name: v-bind with ternary
options: default
--- INPUT ---
<div :class="isActive ? activeClass : inactiveClass"></div>
--- OUTPUT ---
import { normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    class: _normalizeClass(_ctx.isActive ? _ctx.activeClass : _ctx.inactiveClass)
  }, null, 2 /* CLASS */))
}

===
name: v-on directive
options: default
--- INPUT ---
<div v-on:click="handler"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { onClick: _ctx.handler }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on shorthand
options: default
--- INPUT ---
<div @click="handler"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { onClick: _ctx.handler }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on with dynamic arg
options: default
--- INPUT ---
<div v-on:[event]="handler"></div>
--- OUTPUT ---
import { toHandlerKey as _toHandlerKey, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { [_toHandlerKey(_ctx.event)]: _ctx.handler }, null, 16 /* FULL_PROPS */))
}

===
name: v-on shorthand with dynamic arg
options: default
--- INPUT ---
<div @[event]="handler"></div>
--- OUTPUT ---
import { toHandlerKey as _toHandlerKey, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { [_toHandlerKey(_ctx.event)]: _ctx.handler }, null, 16 /* FULL_PROPS */))
}

===
name: v-on with complex dynamic arg
options: default
--- INPUT ---
<div @[getEvent()]="handler"></div>
--- OUTPUT ---
import { toHandlerKey as _toHandlerKey, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { [_toHandlerKey(_ctx.getEvent())]: _ctx.handler }, null, 16 /* FULL_PROPS */))
}

===
name: v-on with modifiers
options: default
--- INPUT ---
<div @click.stop.prevent="handler"></div>
--- OUTPUT ---
import { withModifiers as _withModifiers, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    onClick: _withModifiers(_ctx.handler, ["stop","prevent"])
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on with multiple modifiers
options: default
--- INPUT ---
<div @click.stop.prevent.capture="handler"></div>
--- OUTPUT ---
import { withModifiers as _withModifiers, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    onClickCapture: _withModifiers(_ctx.handler, ["stop","prevent"])
  }, null, 40 /* PROPS, NEED_HYDRATION */, ["onClickCapture"]))
}

===
name: v-on with .once modifier
options: default
--- INPUT ---
<div @click.once="handler"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { onClickOnce: _ctx.handler }, null, 40 /* PROPS, NEED_HYDRATION */, ["onClickOnce"]))
}

===
name: v-on with .passive modifier
options: default
--- INPUT ---
<div @scroll.passive="handler"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { onScrollPassive: _ctx.handler }, null, 40 /* PROPS, NEED_HYDRATION */, ["onScrollPassive"]))
}

===
name: v-on with .self modifier
options: default
--- INPUT ---
<div @click.self="handler"></div>
--- OUTPUT ---
import { withModifiers as _withModifiers, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    onClick: _withModifiers(_ctx.handler, ["self"])
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on with key modifier
options: default
--- INPUT ---
<input @keyup.enter="submit">
--- OUTPUT ---
import { withKeys as _withKeys, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("input", {
    onKeyup: _withKeys(_ctx.submit, ["enter"])
  }, null, 40 /* PROPS, NEED_HYDRATION */, ["onKeyup"]))
}

===
name: v-on with multiple key modifiers
options: default
--- INPUT ---
<input @keyup.ctrl.enter="submit">
--- OUTPUT ---
import { withModifiers as _withModifiers, withKeys as _withKeys, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("input", {
    onKeyup: _withKeys(_withModifiers(_ctx.submit, ["ctrl"]), ["enter"])
  }, null, 40 /* PROPS, NEED_HYDRATION */, ["onKeyup"]))
}

===
name: v-on with mouse button modifier
options: default
--- INPUT ---
<div @click.left="handler"></div>
--- OUTPUT ---
import { withModifiers as _withModifiers, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    onClick: _withModifiers(_ctx.handler, ["left"])
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on with .exact modifier
options: default
--- INPUT ---
<button @click.exact="onClick"></button>
--- OUTPUT ---
import { withModifiers as _withModifiers, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: _withModifiers(_ctx.onClick, ["exact"])
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on inline expression
options: default
--- INPUT ---
<button @click="count++"></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: $event => (_ctx.count++)
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on multiple statements
options: default
--- INPUT ---
<button @click="foo(); bar()"></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: $event => {_ctx.foo(); _ctx.bar()}
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on arrow function
options: default
--- INPUT ---
<button @click="e => handler(e)"></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: e => _ctx.handler(e)
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on arrow function with event
options: default
--- INPUT ---
<button @click="(e) => handler(e)"></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: (e) => _ctx.handler(e)
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on with $event
options: default
--- INPUT ---
<button @click="handler($event)"></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: $event => (_ctx.handler($event))
  }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: v-on object
options: default
--- INPUT ---
<div v-on="handlers"></div>
--- OUTPUT ---
import { toHandlers as _toHandlers, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", _toHandlers(_ctx.handlers, true), null, 16 /* FULL_PROPS */))
}

===
name: v-on with no handler
options: default
errors: v-on is missing expression.
--- INPUT ---
<button @click></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", { onClick: () => {} }, null, 8 /* PROPS */, ["onClick"]))
}

===
name: multiple v-on directives
options: default
--- INPUT ---
<div @click="onClick" @mouseover="onHover" @mouseleave="onLeave"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    onClick: _ctx.onClick,
    onMouseover: _ctx.onHover,
    onMouseleave: _ctx.onLeave
  }, null, 40 /* PROPS, NEED_HYDRATION */, ["onClick", "onMouseover", "onMouseleave"]))
}

===
name: v-model directive
options: default
--- INPUT ---
<input v-model="text">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.text) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelText, _ctx.text]
  ])
}

===
name: v-model with modifiers
options: default
--- INPUT ---
<input v-model.lazy.trim="text">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.text) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [
      _vModelText,
      _ctx.text,
      void 0,
      {
        lazy: true,
        trim: true
      }
    ]
  ])
}

===
name: v-model with .number modifier
options: default
--- INPUT ---
<input v-model.number="age">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.age) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [
      _vModelText,
      _ctx.age,
      void 0,
      { number: true }
    ]
  ])
}

===
name: v-model with .lazy modifier
options: default
--- INPUT ---
<input v-model.lazy="text">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.text) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [
      _vModelText,
      _ctx.text,
      void 0,
      { lazy: true }
    ]
  ])
}

===
name: v-model with .trim modifier
options: default
--- INPUT ---
<input v-model.trim="text">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.text) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [
      _vModelText,
      _ctx.text,
      void 0,
      { trim: true }
    ]
  ])
}

===
name: v-model on textarea
options: default
--- INPUT ---
<textarea v-model="content"></textarea>
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("textarea", {
    "onUpdate:modelValue": $event => ((_ctx.content) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelText, _ctx.content]
  ])
}

===
name: v-model on select
options: default
--- INPUT ---
<select v-model="selected"></select>
--- OUTPUT ---
import { vModelSelect as _vModelSelect, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("select", {
    "onUpdate:modelValue": $event => ((_ctx.selected) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelSelect, _ctx.selected]
  ])
}

===
name: v-model on checkbox
options: default
--- INPUT ---
<input type="checkbox" v-model="checked">
--- OUTPUT ---
import { vModelCheckbox as _vModelCheckbox, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    type: "checkbox",
    "onUpdate:modelValue": $event => ((_ctx.checked) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelCheckbox, _ctx.checked]
  ])
}

===
name: v-model on radio
options: default
--- INPUT ---
<input type="radio" v-model="picked">
--- OUTPUT ---
import { vModelRadio as _vModelRadio, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    type: "radio",
    "onUpdate:modelValue": $event => ((_ctx.picked) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelRadio, _ctx.picked]
  ])
}

===
name: v-model with expression
options: default
--- INPUT ---
<input v-model="form.name">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.form.name) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelText, _ctx.form.name]
  ])
}

===
name: v-model with bracket notation
options: default
--- INPUT ---
<input v-model="items[index]">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.items[_ctx.index]) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelText, _ctx.items[_ctx.index]]
  ])
}

===
name: v-model with multiline
options: default
--- INPUT ---
<input v-model="
  model.foo
">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((
  _ctx.model.foo
) = $event)
  }, null, 8 /* PROPS */, ["onUpdate:modelValue"])), [
    [_vModelText, 
  _ctx.model.foo
]
  ])
}

===
name: v-model with custom arg
options: default
--- INPUT ---
<MyComponent v-model:title="pageTitle" />
--- OUTPUT ---
import { resolveComponent as _resolveComponent, openBlock as _openBlock, createBlock as _createBlock } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return (_openBlock(), _createBlock(_component_MyComponent, {
    title: _ctx.pageTitle,
    "onUpdate:title": $event => ((_ctx.pageTitle) = $event)
  }, null, 8 /* PROPS */, ["title", "onUpdate:title"]))
}

===
name: v-model with custom arg and modifiers
options: default
--- INPUT ---
<MyComponent v-model:title.trim="pageTitle" />
--- OUTPUT ---
import { resolveComponent as _resolveComponent, openBlock as _openBlock, createBlock as _createBlock } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return (_openBlock(), _createBlock(_component_MyComponent, {
    title: _ctx.pageTitle,
    "onUpdate:title": $event => ((_ctx.pageTitle) = $event),
    titleModifiers: { trim: true }
  }, null, 8 /* PROPS */, ["title", "onUpdate:title"]))
}

===
name: multiple v-model
options: default
--- INPUT ---
<MyComponent v-model:first="firstName" v-model:last="lastName" />
--- OUTPUT ---
import { resolveComponent as _resolveComponent, openBlock as _openBlock, createBlock as _createBlock } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return (_openBlock(), _createBlock(_component_MyComponent, {
    first: _ctx.firstName,
    "onUpdate:first": $event => ((_ctx.firstName) = $event),
    last: _ctx.lastName,
    "onUpdate:last": $event => ((_ctx.lastName) = $event)
  }, null, 8 /* PROPS */, ["first", "onUpdate:first", "last", "onUpdate:last"]))
}

===
name: v-slot directive
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template v-slot:header></template>
--- OUTPUT ---


===
name: v-slot shorthand
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #header></template>
--- OUTPUT ---


===
name: v-slot default
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template v-slot></template>
--- OUTPUT ---


===
name: v-slot default shorthand
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #default></template>
--- OUTPUT ---


===
name: v-slot with scope
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template v-slot:default="slotProps"></template>
--- OUTPUT ---


===
name: v-slot shorthand with scope
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #default="{ item }"></template>
--- OUTPUT ---


===
name: v-slot with destructuring
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #default="{ item, index }"></template>
--- OUTPUT ---


===
name: v-slot with nested destructuring
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #default="{ user: { name } }"></template>
--- OUTPUT ---


===
name: v-slot with default value
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #default="{ item = {} }"></template>
--- OUTPUT ---


===
name: v-slot with rest
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #default="{ item, ...rest }"></template>
--- OUTPUT ---


===
name: v-slot with dynamic name
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template v-slot:[slotName]="props"></template>
--- OUTPUT ---


===
name: v-slot shorthand with dynamic name
options: default
errors: Codegen node is missing for element/if/for node. Apply appropriate transforms first.
--- INPUT ---
<template #[slotName]="props"></template>
--- OUTPUT ---


===
name: v-slot on component
options: default
--- INPUT ---
<MyComponent v-slot="{ item }">{{ item }}</MyComponent>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return (_openBlock(), _createBlock(_component_MyComponent, null, {
    default: _withCtx(({ item }) => [
      _createTextVNode(_toDisplayString(item), 1 /* TEXT */)
    ]),
    _: 1 /* STABLE */
  }))
}

===
name: v-slot named on component
options: default
--- INPUT ---
<MyComponent v-slot:header="{ title }">{{ title }}</MyComponent>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return (_openBlock(), _createBlock(_component_MyComponent, null, {
    header: _withCtx(({ title }) => [
      _createTextVNode(_toDisplayString(title), 1 /* TEXT */)
    ]),
    _: 1 /* STABLE */
  }))
}

===
name: multiple slots
options: default
--- INPUT ---
<MyComponent>
  <template #header>Header</template>
  <template #footer>Footer</template>
</MyComponent>
--- OUTPUT ---
import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return (_openBlock(), _createBlock(_component_MyComponent, null, {
    header: _withCtx(() => [
      _createTextVNode("Header")
    ]),
    footer: _withCtx(() => [
      _createTextVNode("Footer")
    ]),
    _: 1 /* STABLE */
  }))
}

===
name: v-show directive
options: default
--- INPUT ---
<div v-show="visible"></div>
--- OUTPUT ---
import { vShow as _vShow, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_vShow, _ctx.visible]
  ])
}

===
name: v-show with expression
options: default
--- INPUT ---
<div v-show="count > 0"></div>
--- OUTPUT ---
import { vShow as _vShow, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_vShow, _ctx.count > 0]
  ])
}

===
name: v-show with method
options: default
--- INPUT ---
<div v-show="isVisible()"></div>
--- OUTPUT ---
import { vShow as _vShow, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_vShow, _ctx.isVisible()]
  ])
}

===
name: v-show with negation
options: default
--- INPUT ---
<div v-show="!hidden"></div>
--- OUTPUT ---
import { vShow as _vShow, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_vShow, !_ctx.hidden]
  ])
}

===
name: v-pre directive
options: default
--- INPUT ---
<div v-pre>{{ raw }}</div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", null, "{{ raw }}"))
}

===
name: v-pre with nested elements
options: default
--- INPUT ---
<div v-pre><span>{{ not interpolated }}</span></div>
--- OUTPUT ---
import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", null, [
    _createElementVNode("span", null, "{{ not interpolated }}")
  ]))
}

===
name: v-pre with directives
options: default
--- INPUT ---
<div v-pre v-if="ignored">content</div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { "v-if": "ignored" }, "content"))
}

===
name: v-cloak directive
options: default
--- INPUT ---
<div v-cloak></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div"))
}

===
name: v-cloak with content
options: default
--- INPUT ---
<div v-cloak>{{ message }}</div>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", null, _toDisplayString(_ctx.message), 1 /* TEXT */))
}

===
name: v-once directive
options: default
--- INPUT ---
<div v-once></div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div")).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once with content
options: default
--- INPUT ---
<div v-once>{{ staticContent }}</div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div", null, [
      _createTextVNode(_toDisplayString(_ctx.staticContent), 1 /* TEXT */)
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once with children
options: default
--- INPUT ---
<div v-once><span>{{ value }}</span></div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createElementVNode("div", null, [
      _createElementVNode("span", null, _toDisplayString(_ctx.value), 1 /* TEXT */)
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-once on component
options: default
--- INPUT ---
<MyComponent v-once />
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, resolveComponent as _resolveComponent, createVNode as _createVNode } from "vue"

export function render(_ctx, _cache) {
  const _component_MyComponent = _resolveComponent("MyComponent")

  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _createVNode(_component_MyComponent)).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: v-memo directive
options: default
--- INPUT ---
<div v-memo="[value]"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([_ctx.value], () => (_openBlock(), _createElementBlock("div")), _cache, 0)
}

===
name: v-memo with multiple dependencies
options: default
--- INPUT ---
<div v-memo="[a, b, c]"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([_ctx.a, _ctx.b, _ctx.c], () => (_openBlock(), _createElementBlock("div")), _cache, 0)
}

===
name: v-memo empty array
options: default
--- INPUT ---
<div v-memo="[]"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return _withMemo([], () => (_openBlock(), _createElementBlock("div")), _cache, 0)
}

===
name: v-memo with v-for
options: default
--- INPUT ---
<div v-for="item in items" :key="item.id" v-memo="[item.selected]"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, isMemoSame as _isMemoSame, withMemo as _withMemo } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.items, (item, __, ___, _cached) => {
    const _memo = ([item.selected])
    if (_cached && _cached.key === item.id && _isMemoSame(_cached, _memo)) return _cached
    const _item = (_openBlock(), _createElementBlock("div", {
      key: item.id
    }))
    _item.memo = _memo
    return _item
  }, _cache, 0), 128 /* KEYED_FRAGMENT */))
}

===
name: v-html directive
options: default
--- INPUT ---
<div v-html="html"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", { innerHTML: _ctx.html }, null, 8 /* PROPS */, ["innerHTML"]))
}

===
name: v-html with expression
options: default
--- INPUT ---
<div v-html="sanitize(content)"></div>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    innerHTML: _ctx.sanitize(_ctx.content)
  }, null, 8 /* PROPS */, ["innerHTML"]))
}

===
name: v-text directive
options: default
--- INPUT ---
<div v-text="text"></div>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    textContent: _toDisplayString(_ctx.text)
  }, null, 8 /* PROPS */, ["textContent"]))
}

===
name: v-text with expression
options: default
--- INPUT ---
<div v-text="message.toUpperCase()"></div>
--- OUTPUT ---
import { toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", {
    textContent: _toDisplayString(_ctx.message.toUpperCase())
  }, null, 8 /* PROPS */, ["textContent"]))
}

===
name: custom directive
options: default
--- INPUT ---
<div v-focus></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_focus = _resolveDirective("focus")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_focus]
  ])
}

===
name: custom directive with value
options: default
--- INPUT ---
<div v-custom="value"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_custom, _ctx.value]
  ])
}

===
name: custom directive with arg
options: default
--- INPUT ---
<div v-custom:arg="value"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_custom, _ctx.value, "arg"]
  ])
}

===
name: custom directive with dynamic arg
options: default
--- INPUT ---
<div v-custom:[arg]="value"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_custom, _ctx.value, _ctx.arg]
  ])
}

===
name: custom directive with modifiers
options: default
--- INPUT ---
<div v-custom.mod1.mod2="value"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [
      _directive_custom,
      _ctx.value,
      void 0,
      {
        mod1: true,
        mod2: true
      }
    ]
  ])
}

===
name: custom directive with arg and modifiers
options: default
--- INPUT ---
<div v-custom:arg.mod1.mod2="value"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [
      _directive_custom,
      _ctx.value,
      "arg",
      {
        mod1: true,
        mod2: true
      }
    ]
  ])
}

===
name: custom directive with dynamic arg and modifiers
options: default
--- INPUT ---
<div v-custom:[arg].mod="value"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [
      _directive_custom,
      _ctx.value,
      _ctx.arg,
      { mod: true }
    ]
  ])
}

===
name: custom directive without value
options: default
--- INPUT ---
<input v-focus>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_focus = _resolveDirective("focus")

  return _withDirectives((_openBlock(), _createElementBlock("input", null, null, 512 /* NEED_PATCH */)), [
    [_directive_focus]
  ])
}

===
name: custom directive with object value
options: default
--- INPUT ---
<div v-tooltip="{ text: msg, position: pos }"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_tooltip = _resolveDirective("tooltip")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_tooltip, { text: _ctx.msg, position: _ctx.pos }]
  ])
}

===
name: custom directive with array value
options: default
--- INPUT ---
<div v-custom="[a, b]"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_custom = _resolveDirective("custom")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_custom, [_ctx.a, _ctx.b]]
  ])
}

===
name: v-if with v-for warning case
options: default
--- INPUT ---
<div v-if="show" v-for="item in items"></div>
--- OUTPUT ---
import { renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache) {
  return (_ctx.show)
    ? (_openBlock(true), _createElementBlock(_Fragment, { key: 0 }, _renderList(_ctx.items, (item) => {
        return (_openBlock(), _createElementBlock("div"))
      }), 256 /* UNKEYED_FRAGMENT */))
    : _createCommentVNode("v-if", true)
}

===
name: v-bind with v-on
options: default
--- INPUT ---
<button :disabled="loading" @click="submit"></button>
--- OUTPUT ---
import { openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    disabled: _ctx.loading,
    onClick: _ctx.submit
  }, null, 8 /* PROPS */, ["disabled", "onClick"]))
}

===
name: v-model with v-bind
options: default
--- INPUT ---
<input v-model="text" :placeholder="placeholder">
--- OUTPUT ---
import { vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.text) = $event),
    placeholder: _ctx.placeholder
  }, null, 8 /* PROPS */, ["onUpdate:modelValue", "placeholder"])), [
    [_vModelText, _ctx.text]
  ])
}

===
name: v-show with v-bind
options: default
--- INPUT ---
<div v-show="visible" :class="{ active: isActive }"></div>
--- OUTPUT ---
import { vShow as _vShow, normalizeClass as _normalizeClass, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  return _withDirectives((_openBlock(), _createElementBlock("div", {
    class: _normalizeClass({ active: _ctx.isActive })
  }, null, 2 /* CLASS */)), [
    [_vShow, _ctx.visible]
  ])
}

===
name: multiple custom directives
options: default
--- INPUT ---
<div v-tooltip="tip" v-click-outside="close"></div>
--- OUTPUT ---
import { resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_tooltip = _resolveDirective("tooltip")
  const _directive_click_outside = _resolveDirective("click-outside")

  return _withDirectives((_openBlock(), _createElementBlock("div", null, null, 512 /* NEED_PATCH */)), [
    [_directive_tooltip, _ctx.tip],
    [_directive_click_outside, _ctx.close]
  ])
}

===
name: v-once with v-show
options: default
--- INPUT ---
<div v-once v-show="visible">static</div>
--- OUTPUT ---
import { setBlockTracking as _setBlockTracking, createTextVNode as _createTextVNode, vShow as _vShow, createElementVNode as _createElementVNode, withDirectives as _withDirectives } from "vue"

export function render(_ctx, _cache) {
  return _cache[0] || (
    _setBlockTracking(-1, true),
    (_cache[0] = _withDirectives(_createElementVNode("div", null, [
      _createTextVNode("static")
    ], 512 /* NEED_PATCH */), [
      [_vShow, _ctx.visible]
    ])).cacheIndex = 0,
    _setBlockTracking(1),
    _cache[0]
  )
}

===
name: all directive types
options: default
--- INPUT ---
<input v-model="text" v-focus :id="inputId" @input="onInput" v-show="visible">
--- OUTPUT ---
import { vModelText as _vModelText, vShow as _vShow, resolveDirective as _resolveDirective, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache) {
  const _directive_focus = _resolveDirective("focus")

  return _withDirectives((_openBlock(), _createElementBlock("input", {
    "onUpdate:modelValue": $event => ((_ctx.text) = $event),
    id: _ctx.inputId,
    onInput: _ctx.onInput
  }, null, 40 /* PROPS, NEED_HYDRATION */, ["onUpdate:modelValue", "id", "onInput"])), [
    [_vModelText, _ctx.text],
    [_directive_focus],
    [_vShow, _ctx.visible]
  ])
}
